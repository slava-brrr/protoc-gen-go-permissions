package main

import (
	"flag"
	"fmt"
	"google.golang.org/protobuf/encoding/protowire"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

var (
	// extensionFieldNumber - номер поля расширения для required_permissions
	extensionFieldNumber = flag.Int("extension-field-number", 50001, "Field number for the required_permissions extension")
)

func main() {
	var flags flag.FlagSet
	flags.IntVar(extensionFieldNumber, "extension-field-number", 50001, "Field number for the required_permissions extension")

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			if err := generateFile(gen, f); err != nil {
				return err
			}
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) error {
	if len(file.Services) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_permissions.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// --- Header ---
	g.P("// Code generated by protoc-gen-go-permissions. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()

	g.P("package ", file.GoPackageName)
	g.P()

	g.P("import (")
	g.P("\"context\"")
	g.P("\"google.golang.org/grpc\"")
	g.P(")")

	// --- Context key ---
	g.P("// contextKey is used to store permissions in context")
	g.P("const contextKey = \"permissions\"")
	g.P()

	// --- Permissions ---
	g.P("var required_permissions = map[string][]string {")

	for _, service := range file.Services {
		for _, method := range service.Methods {
			// 1. Получаем полное имя метода (ключ карты)
			fullMethodName := fmt.Sprintf("/%s.%s/%s",
				file.Desc.Package(), service.Desc.Name(), method.Desc.Name())

			// 2. Получаем дескриптор опций метода
			opts := method.Desc.Options()

			// 3. Проверяем наличие нашего расширения required_permissions
			// Используем рефлексию для получения неизвестных полей опций
			requiredPermsStr := extractUnknownStrings(opts, *extensionFieldNumber)

			// 4. Парсим полученную строку в слайс строк
			if len(requiredPermsStr) == 0 {
				// Опция не установлена или пуста, пропускаем метод.
				continue
			}
			requiredPerms := strings.Split(requiredPermsStr, ",")

			// 5. Записываем в карту
			g.P(fmt.Sprintf("\t%q: {", fullMethodName))
			for _, perm := range requiredPerms {
				g.P(fmt.Sprintf("\t\t%q,", perm))
			}
			g.P("\t},")
		}
	}

	g.P("}")

	g.P("// Permissions maps gRPC full method names (/package.Service/Method) to a list of required permissions.")
	g.P("// NOTE: It relies on the presence of the generated security options file.")
	g.P("func Permissions() map[string][]string {")
	g.P("\ttemp := make(map[string][]string, len(required_permissions))")
	g.P("\tfor k, v := range required_permissions {")
	g.P("\t\ttemp[k] = append([]string{}, v...)")
	g.P("\t}")
	g.P("\treturn temp")
	g.P("}")

	// --- Interceptor ---
	g.P("// UnaryPermissionsInterceptor adds permissions to context based on gRPC method")
	g.P("func UnaryPermissionsInterceptor() grpc.UnaryServerInterceptor {")
	g.P("\treturn func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {")
	g.P("\t\tif p, ok := required_permissions[info.FullMethod]; ok {")
	g.P("\t\t\tctx = context.WithValue(ctx, contextKey, append([]string{}, p...))")
	g.P("\t\t}")
	g.P("\t\treturn handler(ctx, req)")
	g.P("\t}")
	g.P("}")
	g.P()

	// --- Helper to get permissions from context ---
	g.P("// PermissionsFromContext retrieves permissions from context")
	g.P("func PermissionsFromContext(ctx context.Context) []string {")
	g.P("\tif p, ok := ctx.Value(contextKey).([]string); ok {")
	g.P("\t\treturn p")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")

	return nil
}

func extractUnknownStrings(opts protoreflect.ProtoMessage, fieldNumber int) string {
	raw := opts.ProtoReflect().GetUnknown()

	for len(raw) > 0 {
		num, typ, n := protowire.ConsumeTag(raw)
		if n < 0 {
			break
		}
		raw = raw[n:]
		if num != protowire.Number(fieldNumber) {
			// не то поле, пропускаем
			skip := protowire.ConsumeFieldValue(num, typ, raw)
			if skip < 0 {
				break
			}
			raw = raw[skip:]
			continue
		}

		// читаем строку (length-delimited)
		val, m := protowire.ConsumeString(raw)
		if m < 0 {
			break
		}
		return val
	}
	return ""
}
